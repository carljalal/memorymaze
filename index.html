<html>
<head>
<meta name = "viewport" content = "width=device-width, minimum-scale=1.0, maximum-scale = 1.0, user-scalable = no">
<style>
body {touch-action: manipulation;}
div {touch-action: manipulation;}
textarea {touch-action: manipulation;}
</style>
</head>
<body>
<script>


document.body.addEventListener('dblclick', function(event) {
    event.preventDefault();
}, { passive: false });


//wordDict = ["dictionary","for","foreach","if","currentPosition","randomItem",".push","[i]",".style."];
wordDict = [];
checkPlaces = [];
lastCheckPlace = {};
currentTargetPlaceIndex = 0;
mapBoundX = 20;
mapBoundY = 20;
noTyping = true;
allowDuplicates = false;
preventWallOverwrite = true;
emptyChar = "&#160";
centerChar = "X";
itemChar = "O";
wallChar = "Z";
oobChar = "8";
allowDiagonals = false;
let sessionStarted = false;
let startTime = 0.0;
let lastTime = 0.0;
let currentTime = 0.0;
let averageTime = 0.0;
let answerTime = 0.0;
let totalTime = 0.0;
let randchars = false;
let numRandChars = 0;
let allowWalls = true;
let viewDiameter = 5;
let viewRange = 2;
let addRate = 10;


basicRandom = (min,max) => {
    return Math.floor(Math.random() * (max-min+1)) + min;
}

randomItem = (dict) => {
    return dict[basicRandom(0,dict.length - 1)];
}

randomItemDifferent = (dict,unmatch) => {
    for(let i = 0; i < 1000; i++){
        let randomWord = dict[basicRandom(0,dict.length - 1)];
        if (randomWord != unmatch) return randomWord;
    }
    return randomWord;
    feedbackElement.textContent = "we're on duplicates now";
}



randCharList = "`1234567890-=qwertyuiop[]\\asdfasdfghjkl;'zxcvbnm,./~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?";
randNumList = "0123456789";

addCheckPlace = () => {
    let randx = basicRandom(0,mapBoundX-1);
    let randy = basicRandom(0,mapBoundY-1);
    if(preventWallOverwrite){
        for(let i = 0; i <= 1000; i++){
            if(mapVar[randx][randy] != "Z") break;
            randx = basicRandom(0,mapBoundX-1);
            randy = basicRandom(0,mapBoundY-1);
        }
    }
    randWord = "";
    // make sure it's unique
    let found = false;
    for(let i = 0; i <= 1000; i++){
        if(randchars){
            for(let i = 0; i < numRandChars; i++){
                randWord += randCharList[Math.floor(Math.random() * randCharList.length)];
            }
        }
        else randWord = randomItem(wordDict);
        let found = false;
        for(let j = 0; j < checkPlaces.length; j++){
            if(checkPlaces[j].word == randWord) {
                found = true;
                break;
            }
        }
        if (found == false) {
            // unique
            lastCheckPlace = {x:randx,y:randy,word:randWord};
            checkPlaces.push(lastCheckPlace);
            return;
        }
    }

    // if it's a repeat after 1000 times, still add one
    if (allowDuplicates == true){
        lastCheckPlace = {x:randx,y:randy,word:randWord};
        checkPlaces.push(lastCheckPlace);
        feedbackElement.textContent = "we're on duplicates now";
    }

    
}

scoreElement = document.createElement("div");
document.body.append(scoreElement);

mapElement = document.createElement("div");
mapElement.style.display = "none";
document.body.append(mapElement);

mapElement.addEventListener('dblclick', function(event) {
    event.preventDefault();
}, { passive: false });


brElement = document.createElement("div")
document.body.append(brElement)
brElement.innerHTML = "<br>"

leftElement = document.createElement("button");
rightElement = document.createElement("button");
pickupElement = document.createElement("button");
upElement = document.createElement("button");
downElement = document.createElement("button")
putdownElement = document.createElement("button")
initElement = document.createElement("button")
questionElement = document.createElement("div")

questionElement.style.fontFamily = "Verdana";
questionElement.style.fontSize = "20px"
answerElement = document.createElement("textarea")
historyElement = document.createElement("div")
hintElement = document.createElement("div")
feedbackElement = document.createElement("div");
feedbackElement.style.fontFamily = "Verdana";
feedbackElement.style.fontSize = "10px";

checkElement = document.createElement("button");
scoreElement = document.createElement("div");

pickupElement.innerHTML = "pick up"
upElement.innerHTML = "go up!"
downElement.innerHTML = "go down!"
putdownElement.innerHTML = "put down"
initElement.innerHTML = "start"
questionElement.innerHTML = "";
historyElement.innerHTML = "";
hintElement.innerHTML = "";


document.body.append(checkElement);
//document.body.append(upElement)
//document.body.append(downElement)
//document.body.append(leftElement);
//document.body.append(rightElement);
document.body.append(pickupElement)
document.body.append(putdownElement)
document.body.append(initElement)

document.body.append(questionElement)


insideElement = document.createElement("div");
insideElement.style.fontStyle = "italic";
document.body.append(insideElement);

document.body.append(hintElement)
document.body.append(historyElement)
document.body.append(answerElement)
document.body.append(feedbackElement)
document.body.append(scoreElement)


leftElement.innerHTML = "go left!";
rightElement.innerHTML = "go right!";



checkElement.innerHTML = "check!";

answerElement.placeholder = "write list here (each word/phrase separated by a new line)"
answerElement.cols = 50
answerElement.rows = 10

let numCorrect = 0;
let numSteps = 0;



hideShowNonInitButtons = (state) => {
    checkElement.style.display = state
    upElement.style.display = state
    downElement.style.display = state
    leftElement.style.display = state
    rightElement.style.display = state
    //pickupElement.style.display = state
    //putdownElement.style.display = state
}

hideShowNonInitButtons("none");

// add these buttons later
pickupElement.style.display = "none"
putdownElement.style.display = "none"

mapVar = []
displayMapVar = []


setupMap = () => {
for(let i = 0; i < 100; i++){
    mapVar.push([]);
    for(let j = 0; j < 100; j++){
        mapVar[i].push("X");
    }
}

for(let i = 0; i < 5; i++){
    displayMapVar.push([]);
    for(let j = 0; j < 5; j++){
        displayMapVar[i].push("");
    }
}
}

currentPosition = {x: 0, y: 0};


isInsideCheckPlaces = (word) => {
    for(let i = 0; i < checkPlaces.length; i++){
        if(checkPlaces[i].word == word) return true;
    }
    return false;
}



checkAnswer = () => {
    correct = false;
    if(isInsideCheckPlaces(answerElement.value) || noTyping == true){
        if(currentPosition.x == checkPlaces[currentTargetPlaceIndex].x 
        && currentPosition.y == checkPlaces[currentTargetPlaceIndex].y){
            if(basicRandom(0,addRate)==0) addCheckPlace();
            newQuestion();
            correct = true;
        }
    }
    answerElement.value = ""
    if(correct==false) {
        feedbackElement.textContent = "error"
    }
    else {
        feedbackElement.textContent = "you got it!"
        numCorrect++;
        currentTime = performance.now();
        answerTime = currentTime - lastTime;
        totalTime = currentTime - startTime;
        averageTime = totalTime / numCorrect;
        lastTime = currentTime;
        refreshScore();
    }
}

checkElement.onclick = checkAnswer;

refreshMapStyle = () => {
    mapElement.style.fontFamily = "Courier New";
    mapElement.style.fontSize = "50px"
    mapElement.style.border = "5px solid orange"
    mapElement.style.flexWrap = "wrap"
    mapElement.style.whiteSpace = "pre-line";
    mapElement.style.display = "inline-block";
    mapElement.style.userSelect = "none";
}
refreshMapStyle();
mapElement.style.display = "none";

refreshScore = () => {
    let text = "";
    text += "<br><br><br>num correct: " + numCorrect;
    text += "<br>num steps: " + numSteps;
    text += "<br>average steps per question: " + (numSteps / numCorrect).toPrecision(4);
    text += "<br>time for last question: " + (answerTime/1000.0).toPrecision(4) + "s";
    text += "<br>average time per question: " + (averageTime/1000.0).toPrecision(4) + "s";
    text += "<br>words in use: " + checkPlaces.length;
    if (randchars) text += "<br>total words: " + checkPlaces.length;
    else text += "<br>total words: " + wordDict.length;
    scoreElement.innerHTML = text;
    scoreElement.style.fontFamily = "Verdana";
    scoreElement.style.fontSize = "10px";
}



displayMap = () => {
    feedbackElement.textContent = ""
    insideElement.innerHTML = "words inside:<br>";
    for(let checkPlaceIdx = 0; checkPlaceIdx < checkPlaces.length; checkPlaceIdx++){
        if(currentPosition.x == checkPlaces[checkPlaceIdx].x && currentPosition.y == checkPlaces[checkPlaceIdx].y){
            insideElement.innerHTML += checkPlaces[checkPlaceIdx].word + "<br>";
        }
    }

    // write the O for all positions which is a check place
    for(let i = 0; i < checkPlaces.length; i++){
        let xx = checkPlaces[i].x;
        let yy = checkPlaces[i].y;
        mapVar[xx][yy] = "O";
    }

    for(let xx = currentPosition.x - viewRange; xx <= currentPosition.x + viewRange; xx++){
        for(let yy = currentPosition.y - viewRange; yy <= currentPosition.y + viewRange; yy++){
            if(xx < 0 || yy < 0) displayMapVar[xx - currentPosition.x + viewRange][yy - currentPosition.y + viewRange] = "8";
            else if(xx >= mapBoundX || yy >= mapBoundY) displayMapVar[xx - currentPosition.x + viewRange][yy - currentPosition.y + viewRange] = "8";
            else displayMapVar[xx - currentPosition.x + viewRange][yy - currentPosition.y + viewRange] = mapVar[xx][yy];
        }
    }
    mapElement.innerHTML = "";
    let tempText = "";
    for(let yy = 0; yy < viewDiameter; yy++){
        for(let xx = 0; xx < viewDiameter; xx++){
            let center = false;
            if(xx == viewRange && yy == viewRange) {
                center = true;
            }
            if(center) {
                tempText+= "<span style=\"font-weight:bold;color:aqua\">";
            }
            let c = displayMapVar[xx][yy];

            if (c == "Z") tempText += wallChar;
            if (c == "8") tempText += oobChar;
            if (c == "O" && !center) tempText += itemChar;
            if (c == "X" && !center) tempText += emptyChar;
            if (center) tempText += centerChar;
            
            tempText += " ";
            if(center) {
                tempText+= "</span>"
            }
        }
        if (yy < viewDiameter - 1) tempText+= "<br>";
    }
    mapElement.innerHTML = tempText;
    refreshMapStyle();
    refreshScore();
}


isWalkable = (x,y) => {
    if(x < 0) return false;
    if(x >= mapBoundX) return false;
    if(y < 0) return false;
    if(y >= mapBoundY) return false;
    if(mapVar[x][y] == "Z"){
        return false;
    }
    return true;
}


moveLeft = () => {
    if(isWalkable(currentPosition.x-1,currentPosition.y)) {
        currentPosition.x--;
        numSteps++;
        displayMap();
    }
}

moveRight = () => {
    if(isWalkable(currentPosition.x+1,currentPosition.y)) {
        currentPosition.x++;
        numSteps++;
        displayMap();
    }
}

moveUp = () => {
    if(isWalkable(currentPosition.x,currentPosition.y-1)) {
        currentPosition.y--;
        numSteps++;
        displayMap();
    }
}

moveDown = () => {
    if(isWalkable(currentPosition.x,currentPosition.y+1)) {
        currentPosition.y++;
        numSteps++;
        displayMap();
    }
}

mapElement.addEventListener("pointerdown",(event) => {
    let rect = mapElement.getBoundingClientRect();
    let midx = (rect.left + rect.right)/2.0;
    let midy = (rect.top + rect.bottom)/2.0;
    if(event.x > midx + 20 && event.y < midy + 50 && event.y > midy - 50) moveRight();
    if(event.x < midx - 20 && event.y < midy + 50 && event.y > midy - 50) moveLeft();
    if(event.y > midy + 20 && event.x < midx + 50 && event.x > midx - 50) moveDown();
    if(event.y < midy - 20 && event.x < midx + 50 && event.x > midx - 50) moveUp();
})


leftElement.onclick = () => {
    moveLeft();
}
rightElement.onclick = () => {
    moveRight();
}
upElement.onclick = () => {
    moveUp();
}
downElement.onclick = () => {
    moveDown();
}

newQuestion = () => {
    let lastTargetPlace = currentTargetPlaceIndex;
    for (let i = 0; i < 1000; i++){
        currentTargetPlaceIndex = basicRandom(0,checkPlaces.length-1)
        if(currentTargetPlaceIndex != lastTargetPlace) break;
    }
    questionElement.innerHTML = "go to " + checkPlaces[currentTargetPlaceIndex].word;
    
}

removeItemAll = (arr, value) => {
  var i = 0;
  while (i < arr.length) {
    if (arr[i] === value) {
      arr.splice(i, 1);
    } else {
      ++i;
    }
  }
  return arr;
}



setMapVar = () => {
    for(let i = 0; i < mapBoundX; i++){
        mapVar.push([]);
        for(let j = 0; j < mapBoundY; j++){
            mapVar[i].push("X");
        }
    }
}



goodWall = (x,y) => {
    wallcheck = [["","",""],["","",""],["","",""]];
    for(let xcheck = -1; xcheck <=1; xcheck++){
        for(let ycheck = -1; ycheck <=1; ycheck++){
            if(x + xcheck < 0 || x + xcheck >= mapBoundX) wallcheck[xcheck+1][ycheck+1] = "Z";
            else if(y + ycheck < 0 || y + ycheck >= mapBoundY) wallcheck[xcheck+1][ycheck+1] = "Z";
            else {
                wallcheck[xcheck+1][ycheck+1] = mapVar[x+xcheck][y+ycheck];
            }
        }
    }
    if(wallcheck[1][1] == "Z") return false; 
    if(wallcheck[1][0] == "Z" || wallcheck[0][0] == "Z" || wallcheck[2][0] == "Z") {
        if(wallcheck[0][2] == "Z" || wallcheck[1][2] == "Z" || wallcheck[2][2] == "Z" ){
            return false;
        }
    }
    if(wallcheck[0][1] == "Z" || wallcheck[0][0] == "Z" || wallcheck[0][2] == "Z") {
        if(wallcheck[2][0] == "Z" || wallcheck[2][1] == "Z" || wallcheck[2][2] == "Z" ){
            return false;
        }
    }
    if(wallcheck[1][2] == "Z" || wallcheck[0][2] == "Z" || wallcheck[2][2] == "Z") {
        if(wallcheck[0][0] == "Z" || wallcheck[1][0] == "Z" || wallcheck[2][0] == "Z" ){
            return false;
        }
    }
    if(wallcheck[2][1] == "Z" || wallcheck[2][0] == "Z" || wallcheck[2][2] == "Z") {
        if(wallcheck[0][0] == "Z" || wallcheck[0][1] == "Z" || wallcheck[0][2] == "Z" ){
            return false;
        }
    }
    return true;
}

goodWallPure = (x,y) => {
    if(x < 0 || x >= mapBoundX || y < 0 || y >= mapBoundY) return false;
    wallcheck = [["","",""],["","",""],["","",""]];
    for(let xcheck = -1; xcheck <=1; xcheck++){
        for(let ycheck = -1; ycheck <=1; ycheck++){
            // is pt within bounds
            if(x + xcheck >= 0 && x + xcheck < mapBoundX) {
                if(y + ycheck >= 0 && y + ycheck < mapBoundY) {
                    //let s = " " + (x) + " " + (y);
                    //console.log(s)
                    //s = " " + (x+xcheck) + " " + (y+ycheck);
                    //console.log(s)
                    if(mapVar[x+xcheck][y+ycheck] == "Z") return false; 
                }
            }
        }
    }
    return true;
}


let walls = [];

makeWallAny = () => {
    let x = basicRandom(0,mapBoundX-1);
    let y = basicRandom(0,mapBoundY-1);
    if(goodWallPure(x,y)) {
        mapVar[x][y] = "Z";
        walls.push({x:x,y:y});
    }
}

makeWallNearby = () => {
    let r = basicRandom(0,walls.length-1);
    let x = walls[r].x;
    let y = walls[r].y;

    if(allowDiagonals){
        x = walls[r].x + basicRandom(-1,1);
        y = walls[r].y + basicRandom(-1,1);
    }
    else{
        if(basicRandom(0,1)==0){
            x+=basicRandom(-1,1);
        }
        else {
            y+=basicRandom(-1,1);
        }
    }
    
    if(goodWall(x,y)) {
        mapVar[x][y] = "Z";
        walls.push({x:x,y:y});
    }
}


wallAlgorithm = () => {
    
    makeWallAny();
    for ( let i = 0; i < 1000; i ++){
        let r = basicRandom(0,10);
        if(r==0){
            makeWallAny();
        }
        else {
            makeWallNearby();
        }
    }
    
}

initElement.onclick = () => {
    sessionStarted = true;
    startTime = performance.now();
    lastTime = startTime;
    answerElement.placeholder = "type here and hit check!"
    hideShowNonInitButtons("");
    refreshMapStyle();
    if (noTyping == true) answerElement.style.display = "none"
    initElement.style.display = "none"

    wordListString = answerElement.value
    wordListString = wordListString.replace("\r\g","");
    wordListArray = wordListString.split("\n");
    wordListArray = removeItemAll(wordListArray,"");
    for(let i = 0; i < wordListArray.length; i++){
        if(wordListArray[i].substr(0,5).toLowerCase() == "mapx "){
            mapBoundX = parseInt(wordListArray[i].substring(5));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,5).toLowerCase() == "mapy "){
            mapBoundY = parseInt(wordListArray[i].substring(5));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,10).toLowerCase() == "randchars "){
            randchars = true;
            numRandChars = parseInt(wordListArray[i].substring(10));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,9).toLowerCase() == "randnums "){
            randchars = true;
            numRandChars = parseInt(wordListArray[i].substring(9));
            randCharList = randNumList;
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,7).toLowerCase() == "nowalls"){
            allowWalls = false;
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,10).toLowerCase() == "viewrange "){
            viewRange = parseInt(wordListArray[i].substring(10));
            viewDiameter = 1 + (viewRange * 2);
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,8).toLowerCase() == "addrate "){
            addRate = parseInt(wordListArray[i].substring(8));
            wordListArray.splice(i,1);
            i--;
        }
    }
    wordDict = wordListArray;
    
    answerElement.value = "";
    answerElement.cols = 50
    answerElement.rows = 1

    mapElement.style.display = ""

    
    checkPlaces = [];
    lastCheckPlace = {};

    mapVar = []
    displayMapVar = []

    setMapVar();

    if(allowWalls){
        wallAlgorithm();
    }

    for(let i = 0; i < viewDiameter; i++){
        displayMapVar.push([]);
        for(let j = 0; j < viewDiameter; j++){ 
            displayMapVar[i].push("");
        }
    }


    currentPosition = {x: 0, y: 0};
    for(let i = 1; i <= 3; i++) addCheckPlace();
    newQuestion();
    displayMap();
    
}

document.body.addEventListener("keydown", (event)=>{
    if(event.key == "Enter" && sessionStarted) checkAnswer(); 
    if(event.key == "ArrowUp" && sessionStarted) moveUp(); 
    if(event.key == "ArrowDown" && sessionStarted) moveDown(); 
    if(event.key == "ArrowLeft" && sessionStarted) moveLeft(); 
    if(event.key == "ArrowRight" && sessionStarted) moveRight(); 
})


</script>
</body>
</html>