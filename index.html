<html>
<head>
<meta name = "viewport" content = "width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
<style>
body {touch-action: manipulation;}
div {touch-action: manipulation;}
textarea {touch-action: manipulation;}
</style>
</head>
<body>
<script>


document.body.addEventListener('dblclick', function(event) {
    event.preventDefault();
}, { passive: false });

document.ondblclick = function(e) {
    e.preventDefault();
}



//wordDict = ["dictionary","for","foreach","if","currentPosition","randomItem",".push","[i]",".style."];
let wordDict = [];
let checkPlaces = [];
let lastCheckPlace = {};
let instructionOrder = [];
let currentPosition = {x: 0, y: 0, room:0,pickedUpWord:""};
let mapBoundX = 10;
let mapBoundY = 10;
let noTyping = true;
let allowDuplicates = false;
let preventWallOverwrite = true;
let emptyChar = "&#160";
let centerChar = "X";
let itemChar = "O";
let wallChar = "Z";
let oobChar = "8";
let warpChar = "W";
let allowDiagonals = false;
let sessionStarted = false;
let startTime = 0.0;
let lastTime = 0.0;
let currentTime = 0.0;
let averageTime = 0.0;
let answerTime = 0.0;
let totalTime = 0.0;
let randchars = false;
let numRandChars = 0;
let allowWalls = true;
let viewDiameter = 5;
let viewRange = 2;
let addRate = 10;
let numStartingPlaces = 4;
let allowHints = true;
let multipleRooms = true;
let numRooms = 4;
let numExtraConnections = 0;
let minMapX = 4;
let minMapY = 4;
let maxMapX = 8;
let maxMapY = 8;
let bidirectionalWarps = true;
let moveAroundMode = false;
let showPosition = false;
let allowStacking = true;
let numTriesSuitable = 10000;
let moveToRate = 10;
let newRoomMode = false;
let newRoomRate = 20;
let numIncomingInstructions = 4;
let answerOutOfOrder = false;
let answering = false;
let mathQuestions = true;
let mathQuestionsRate = 5;
let mathQuestionsDepth = 4;
let clickQuestions = true;
let clickQuestionsRate = 5;
let timerQuestions = true;
let timerQuestionsRate = 0.03;
let paused = false;
let SVGQuestions = false;
let SVGQuestionsRate = 1;
let maxClickReps = 5;


let mapVar = [];
let displayMapVar = [];






let dCopy = (o) => {
    return JSON.parse(JSON.stringify(o));
}



let RGBToString = (r,g,b) => {
    return `rgb(${r},${g},${b})`
}

let RGBObjectToString = (o) => {
    return RGBToString(o.r,o.g,o.b);
}


let randColorObject = () => {
    let r = Math.floor(Math.random()*27);
    let g = Math.floor(Math.random()*27);
    let b = Math.floor(Math.random()*27);
    r *= 10;
    g *= 10;
    b *= 10;
    r = Math.min(255,r);
    g = Math.min(255,g);
    b = Math.min(255,b);
    return {r:r,g:g,b:b,string:RGBToString(r,g,b)};
}

let randColorString = () => {
    o = randColorObject();
    return RGBObjectToString(o);
}


let randSize = (r) => {
    return 10+Math.floor(Math.random()*r/10)*10;
}


let stringSVGCircle = (o) => {
    let svgString = `<circle cx="` + o.x;
    svgString += `" cy="` + o.y;
    svgString += `" r="` + o.size;
    svgString += `" stroke="` + RGBObjectToString(o.strokeColorObject);
    svgString += `" stroke-width="10"`;
    svgString += ` fill="` + RGBObjectToString(o.fillColorObject);
    svgString += `" />`;
    return svgString;
}

let stringSVGRect = (o) => {
    return `<rect width="${o.xSVG}" height="${o.ySVG}" style="fill:${RGBObjectToString(o.fillColorObject)};stroke:${RGBObjectToString(o.strokeColorObject)};stroke-width:${20}"/>`;
}


let SVGHTMLGroup = (o) => {
    let s = "";
    s += stringSVGRect(o.square);
    s += stringSVGCircle(o.circle1);
    s += stringSVGCircle(o.circle2);
    return wrapInSVG(s,o.xSVG,o.ySVG);
}


let wrapInSVG = (svgString,xSVG,ySVG) => {
    return `<svg width="${xSVG}" height="${ySVG}">` + svgString + `</svg>`;
}

let circleSVGConfig = (xSVG,ySVG,x,y)  => {
    return {type:"circle",fillColorObject:randColorObject(), strokeColorObject:randColorObject(), size: randSize(ySVG/3),x:x,y:y,xSVG:xSVG,ySVG:ySVG};
}

let randSVGConfig = () => {
    let xSVG = 150;
    let ySVG = 80;
    let x = xSVG/3;
    let y = ySVG/2;
    return {circle1:circleSVGConfig(xSVG,ySVG,x,y), circle2:circleSVGConfig(xSVG,ySVG,x*2,y), square:circleSVGConfig(xSVG,ySVG,x*1.5,y), xSVG:xSVG, ySVG:ySVG};
}



let pauseElement = document.createElement("button");
pauseElement.innerHTML = "pause";
pauseElement.onclick = () => {
    if(paused) {
        paused = false;
        pauseElement.innerHTML = "pause";
    }
    else {
        paused = true;
        pauseElement.innerHTML = "unpause";
    }
}




refreshTimerQuestion = (element) => {
    if (!paused) {
        element.timeLeft--;
        element.style.left = basicRandom(400,1000);
        element.style.top = basicRandom(50,800);
        element.style.border = "2px solid black";
        element.textContent = "timer " + element.timeLeft + " > " + element.timeReady;
        element.style.width = basicRandom(80,100);
        element.style.height = basicRandom(20,50);
        element.style.position = "absolute";
        element.style.fontFamily = "Verdana";
    }
    if(element.timeLeft < 0) {
        timerQuestion();
        feedbackElement += "<br>timer question elapsed";
        element.timeReady = element.originalTimeReady;
        element.timeLeft = element.originalTimeLeft;
    }
    element.timer = setTimeout(() => {refreshTimerQuestion(element)}, 1000);
}

checkTimerQuestion = (element) => {
    if(element.timeLeft < element.timeReady){
        clearTimeout(element.timer);
        element.remove();
        scoreCorrect();
        refreshScore();
        feedbackElement += "<br>you got the timer question!";
    }
}

timerQuestion = () => {
    let element = document.createElement("div");
    element.timeReady = basicRandom(3,30);
    element.timeLeft = basicRandom(element.timeReady,100);
    element.originalTimeReady = element.timeReady;
    element.originalTimeLeft = element.timeLeft;
    element.addEventListener("pointerdown", () => {checkTimerQuestion(element)});
    document.body.append(element);
    refreshTimerQuestion(element);
}


let timerQuestionsTimer = () => {
    if(!timerQuestions || paused || !sessionStarted) return;
    let r = Math.random();
    if (r < timerQuestionsRate){
        timerQuestion();
    }
}

setInterval(timerQuestionsTimer, 1000);

basicRandom = (min,max) => {
    return Math.floor(Math.random() * (max-min+1)) + min;
}

randomItem = (dict) => {
    return dict[basicRandom(0,dict.length - 1)];
}

randomItemDifferent = (dict,unmatch) => {
    for(let i = 0; i < 1000; i++){
        let randomWord = dict[basicRandom(0,dict.length - 1)];
        if (randomWord != unmatch) return randomWord;
    }
    return randomWord;
    feedbackElement.textContent = "we're on duplicates now";
}



let randCharList = "`1234567890-=qwertyuiop[]\\asdfasdfghjkl;'zxcvbnm,./~!@#$%^&*()_+QWERTYUIOP{}|ASDFGHJKL:\"ZXCVBNM<>?";
let randNumList = "0123456789";

getRandChar = () => {
    return randCharList[Math.floor(Math.random() * randCharList.length)];
}

addCheckPlace = () => {
    let randroom = basicRandom(0, numRooms-1);
    let randx = basicRandom(0,mapVar[randroom].mapBoundX-1);
    let randy = basicRandom(0,mapVar[randroom].mapBoundY-1);
    for(let i = 0; i <= 1000; i++){
        if(mapVar[randroom].xy[randx][randy] != "Z" || !preventWallOverwrite) {
            if(mapVar[randroom].xy[randx][randy] != "W") {
                break;
            }
        }
        randroom = basicRandom(0, numRooms-1);
        randx = basicRandom(0,mapVar[randroom].mapBoundX-1);
        randy = basicRandom(0,mapVar[randroom].mapBoundY-1);
    }
    
    let randWord = "";
    // make sure it's unique
    let found = false;
    for(let i = 0; i <= 1000; i++){
        let randCharsRate = 0;
        if(randchars) randCharsRate = 1;
        if(!SVGQuestions) SVGQuestionsRate = 0;

        let totalChance = randCharsRate + SVGQuestionsRate;
        let chance = basicRandom(1,totalChance);
        let wordType = "default";
        let thisSvgConfig = null;

        if(SVGQuestions && wordDict.length <= checkPlaces.length && chance > randCharsRate){
            wordType = "svg";
            thisSvgConfig = randSVGConfig();
            randWord = SVGHTMLGroup(thisSvgConfig);
        }
        if(randchars && wordDict.length <= checkPlaces.length && chance <= randCharsRate){
            wordType = "randchar";
            for(let i = 0; i < numRandChars; i++){
                randWord += randCharList[Math.floor(Math.random() * randCharList.length)];
            }
        }
        if(wordType == "default") randWord = randomItem(wordDict);
        let found = false;
        for(let j = 0; j < checkPlaces.length; j++){
            if(checkPlaces[j].word == randWord) {
                found = true;
                break;
            }
        }
        if (found == false) {
            // unique
            lastCheckPlace = {x:randx,y:randy,room: randroom,word:randWord,wordType:wordType,svgConfig:thisSvgConfig};
            checkPlaces.push(lastCheckPlace);
            mapVar[randroom].places.push(lastCheckPlace);
            if(allowHints){
                feedbackElement.textContent += "new place added:\n";
                feedbackElement.textContent += JSON.stringify(lastCheckPlace);
            }
            return;
        }
    }

    // if it's a repeat after 1000 times, still add one
    if (allowDuplicates == true){
        lastCheckPlace = {x:randx,y:randy,room:randroom,word:randWord};
        checkPlaces.push(lastCheckPlace);
        feedbackElement.textContent = "we're on duplicates now\n";
        if(allowHints){
            feedbackElement.textContent += "new place added:\n";
            feedbackElement.textContent += JSON.stringify(lastCheckPlace);
        }
    }
}


findSuitableMovePlace = () => {
    let randroom = basicRandom(0, numRooms-1);
    let randx = basicRandom(0,mapVar[randroom].mapBoundX-1);
    let randy = basicRandom(0,mapVar[randroom].mapBoundY-1);
    for(let i = 0; i <= 10000; i++){
        if(mapVar[randroom].xy[randx][randy] != "Z" || !preventWallOverwrite) {
            if(mapVar[randroom].xy[randx][randy] != "W") {
                if(mapVar[randroom].xy[randx][randy] != "O" || allowStacking) {
                    break;
                }
            }
        }
        randroom = basicRandom(0, numRooms-1);
        randx = basicRandom(0,mapVar[randroom].mapBoundX-1);
        randy = basicRandom(0,mapVar[randroom].mapBoundY-1);
    }
    
    return {x:randx,y:randy,room: randroom};
}


mapElement = document.createElement("div");
mapElement.style.display = "none";
document.body.append(mapElement);

mapElement.addEventListener('dblclick', function(event) {
    event.preventDefault();
}, { passive: false });


brElement = document.createElement("div");
document.body.append(brElement);
brElement.innerHTML = "<br>";

leftElement = document.createElement("button");
rightElement = document.createElement("button");
pickupElement = document.createElement("button");
upElement = document.createElement("button");
downElement = document.createElement("button");
putdownElement = document.createElement("button");
initElement = document.createElement("button");
questionElement = document.createElement("div");

questionElement.style.fontFamily = "Verdana";
questionElement.style.fontSize = "20px";
questionElement.style.border = "5px solid black";
answerElement = document.createElement("textarea");
historyElement = document.createElement("div");
hintElement = document.createElement("div");
feedbackElement = document.createElement("div");
feedbackElement.style.fontFamily = "Verdana";
feedbackElement.style.fontSize = "10px";
feedbackElement.style.whiteSpace = "pre";
feedbackElement.style.border = "2px solid red";


checkElement = document.createElement("button");
scoreElement = document.createElement("div");
scoreElement.style.border = "2px solid lime";

pickupElement.innerHTML = "pick up";
upElement.innerHTML = "go up!";
downElement.innerHTML = "go down!";
putdownElement.innerHTML = "put down";
initElement.innerHTML = "start";
questionElement.innerHTML = "";
historyElement.innerHTML = "";
hintElement.innerHTML = "";

document.body.append(questionElement)
document.body.append(checkElement);
//document.body.append(upElement)
//document.body.append(downElement)
//document.body.append(leftElement);
//document.body.append(rightElement);
document.body.append(pickupElement)
document.body.append(putdownElement)
document.body.append(initElement)

document.body.append(document.createElement("br"));
document.body.append(document.createElement("br"));


insideElement = document.createElement("div");
insideElement.style.fontStyle = "italic";
insideElement.style.border = "4px solid purple"
document.body.append(insideElement);
document.body.append(document.createElement("br"));

document.body.append(hintElement)
document.body.append(historyElement)
document.body.append(answerElement)
document.body.append(document.createElement("br"));
document.body.append(feedbackElement)
document.body.append(document.createElement("br"));
document.body.append(document.createElement("br"));
document.body.append(scoreElement)
document.body.append(document.createElement("br"));
document.body.append(document.createElement("br"));
document.body.append(pauseElement);

questionElement.style.padding = "5px";
insideElement.style.padding = "5px";
feedbackElement.style.padding = "5px";
scoreElement.style.padding = "5px";

questionElement.style.margin = "5px";
insideElement.style.margin = "5px";
feedbackElement.style.margin = "5px";
scoreElement.style.margin = "5px";


leftElement.innerHTML = "go left!";
rightElement.innerHTML = "go right!";



checkElement.innerHTML = "select";

answerElement.placeholder = "write list here (each word/phrase separated by a new line)"
answerElement.cols = 50
answerElement.rows = 10

let numCorrect = 0;
let numSteps = 0;



hideShowNonInitButtons = (state) => {
    checkElement.style.display = state
    upElement.style.display = state
    downElement.style.display = state
    leftElement.style.display = state
    rightElement.style.display = state
    feedbackElement.style.display = state;
    scoreElement.style.display = state;
    mapElement.style.display = state;
    insideElement.style.display = state;
    questionElement.style.display = state;
    pauseElement.style.display = state;
    //pickupElement.style.display = state
    //putdownElement.style.display = state
}

hideShowNonInitButtons("none");

// add these buttons later
pickupElement.style.display = "none"
putdownElement.style.display = "none"


/*
setupMap = () => {
for(let i = 0; i < 100; i++){
    mapVar.push([]);
    for(let j = 0; j < 100; j++){
        mapVar[i].push("X");
    }
}

for(let i = 0; i < 5; i++){
    displayMapVar.push([]);
    for(let j = 0; j < 5; j++){
        displayMapVar[i].push("");
    }
}
}
*/


/*
isInsideCheckPlaces = (word) => {
    for(let i = 0; i < checkPlaces.length; i++){
        if(checkPlaces[i].word == word) return true;
    }
    return false;
}
*/

isInsideCheckPlaces = (word,c) => {
    if(checkPlaces[instructionOrder[c].targetPlaceIndex].word == word) return true;
    return false;
}


let scoreCorrect = () => {
    numCorrect++;
    currentTime = performance.now();
    answerTime = currentTime - lastTime;
    totalTime = currentTime - startTime;
    averageTime = totalTime / numCorrect;
    lastTime = currentTime;
}

let isInstructionSVG = (c) => {
    if(instructionOrder[c].questionType == "math") return false;
    if(instructionOrder[c].questionType == "click") return false;
    return checkPlaces[instructionOrder[c].targetPlaceIndex].wordType == "svg";
}


checkAnswer = (c = 0) => {
    correct = false;
    if(instructionOrder[c].questionType == "math"){
        if(answerElement.value == instructionOrder[c].answer){
            if(basicRandom(0,addRate)==0) addCheckPlace();
            if(newRoomMode && basicRandom(0,newRoomRate)==0) addRoom();
            newQuestion(true, c);
            correct = true;
        }
    }
    if(instructionOrder[c].questionType == "goTo" && correct == false){
        if(isInsideCheckPlaces(answerElement.value,c) || noTyping == true || isInstructionSVG(c)){
            if(currentPosition.x == checkPlaces[instructionOrder[c].targetPlaceIndex].x 
            && currentPosition.y == checkPlaces[instructionOrder[c].targetPlaceIndex].y 
            && currentPosition.room == checkPlaces[instructionOrder[c].targetPlaceIndex].room ){                
                if(basicRandom(0,addRate)==0) addCheckPlace();
                if(newRoomMode && basicRandom(0,newRoomRate)==0) addRoom();
                newQuestion(true, c);
                if (c < instructionOrder.length){
                    if(instructionOrder[c].questionType == "moveTo"){
                        let cpy = {...instructionOrder[c]};
                        instructionOrder.splice(c,1);
                        instructionOrder.splice(0,0,cpy);
                    }
                }
                correct = true;
            }
        }
    }
    if(instructionOrder[c].questionType == "moveTo" && c == 0 && correct == false){
        if(isInsideCheckPlaces(answerElement.value,c) || noTyping == true || isInstructionSVG(c)){
            if(currentPosition.x == instructionOrder[c].moveToX 
            && currentPosition.y == instructionOrder[c].moveToY
            && currentPosition.room == instructionOrder[c].room){
                checkPlaces[instructionOrder[c].targetPlaceIndex].x = instructionOrder[c].moveToX;
                checkPlaces[instructionOrder[c].targetPlaceIndex].y = instructionOrder[c].moveToY;
                checkPlaces[instructionOrder[c].targetPlaceIndex].room = instructionOrder[c].moveToRoom;
                checkPlaces[instructionOrder[c].targetPlaceIndex].pickedUp = false;
                refreshWordsInside();
                newQuestion(true, c);
                correct = true;
            }
        }
    }
    answerElement.value = ""
    if(correct==false) {
        feedbackElement.textContent += "\nerror"
    }
    else {
        feedbackElement.textContent += "\nyou got it!"
        scoreCorrect();
        refreshScore();
    }
}

checkAnswers = () => {
    if(answerOutOfOrder){
        for(let i = 0; i < instructionOrder.length;i++) checkAnswer(i);
    }
    else checkAnswer(0);
}

checkElement.onclick = () => {
    let room = currentPosition.room;
    let x = currentPosition.x;
    let y = currentPosition.y;
    if(mapVar[room].xy[x][y] == "W"){
        goInside(room, x, y);
    }
    else checkAnswers(); 
}

refreshMapStyle = () => {
    mapElement.style.fontFamily = "Courier New";
    mapElement.style.fontSize = "50px"
    mapElement.style.border = "5px solid orange"
    mapElement.style.flexWrap = "wrap"
    mapElement.style.whiteSpace = "pre-line";
    mapElement.style.display = "inline-block";
    mapElement.style.userSelect = "none";
}
refreshMapStyle();
mapElement.style.display = "none";
feedbackElement.style.display = "none";
scoreElement.style.display = "none";
mapElement.style.display = "none";
insideElement.style.display = "none";
questionElement.style.display = "none";
pauseElement.style.display = "none";

feedbackElement.style.flexWrap = "wrap";
scoreElement.style.flexWrap = "wrap";
mapElement.style.flexWrap = "wrap";
insideElement.style.flexWrap = "wrap";
questionElement.style.flexWrap = "wrap";



refreshScore = () => {
    let text = "";
    text += "Info:<br>num correct: " + numCorrect;
    text += "<br>num steps: " + numSteps;
    text += "<br>average steps per question: " + (numSteps / numCorrect).toPrecision(4);
    text += "<br>time for last question: " + (answerTime/1000.0).toPrecision(4) + "s";
    text += "<br>average time per question: " + (averageTime/1000.0).toPrecision(4) + "s";
    text += "<br>words in use: " + checkPlaces.length;
    if (checkPlaces.length < wordDict.length) text += "<br>total words: " + wordDict.length;
    else text += "<br>total words: " + checkPlaces.length;
    //if (lastQuestionType == "moveTo") 
    text += "<br>currentposition: " + JSON.stringify(currentPosition);
    scoreElement.innerHTML = text;
    scoreElement.style.fontFamily = "Verdana";
    scoreElement.style.fontSize = "10px";
}

refreshCheckPlaces = (room) => {
    // write the O for all positions which is a check place
    for(let i = 0; i < checkPlaces.length; i++){
        if(checkPlaces[i].pickedUp == true) continue;
        if(checkPlaces[i].room != currentPosition.room) continue;
        let xx = checkPlaces[i].x;
        let yy = checkPlaces[i].y;
        room.xy[xx][yy] = "O";
    }
}

refreshWordsInside = () => {
    insideElement.innerHTML = "words inside:<br>";
    for(let checkPlaceIdx = 0; checkPlaceIdx < checkPlaces.length; checkPlaceIdx++){
        if(checkPlaces[checkPlaceIdx].pickedUp == true) continue;
        if(currentPosition.x == checkPlaces[checkPlaceIdx].x 
        && currentPosition.y == checkPlaces[checkPlaceIdx].y
        && currentPosition.room == checkPlaces[checkPlaceIdx].room){
            insideElement.innerHTML += checkPlaces[checkPlaceIdx].word + "<br>";
        }
    }
}


displayMap = () => {
    let room = mapVar[currentPosition.room];
    feedbackElement.textContent = "Feedback: \n";
    
    refreshWordsInside();

    refreshCheckPlaces(room);

    // write the W for all positions which is a warp place
    for(let i=0; i < room.warps.length; i++){
        room.xy[room.warps[i].x][room.warps[i].y] = "W"; 
    }

    for(let xx = currentPosition.x - viewRange; xx <= currentPosition.x + viewRange; xx++){
        for(let yy = currentPosition.y - viewRange; yy <= currentPosition.y + viewRange; yy++){
            if(xx < 0 || yy < 0) displayMapVar[xx - currentPosition.x + viewRange][yy - currentPosition.y + viewRange] = "8";
            else if(xx >= room.mapBoundX || yy >= room.mapBoundY) displayMapVar[xx - currentPosition.x + viewRange][yy - currentPosition.y + viewRange] = "8";
            else displayMapVar[xx - currentPosition.x + viewRange][yy - currentPosition.y + viewRange] = room.xy[xx][yy];
        }
    }
    mapElement.innerHTML = "";
    let tempText = "";
    for(let yy = 0; yy < viewDiameter; yy++){
        for(let xx = 0; xx < viewDiameter; xx++){
            let center = false;
            if(xx == viewRange && yy == viewRange) {
                center = true;
            }
            if(center) {
                tempText+= "<span style=\"font-weight:bold;color:aqua\">";
            }
            let c = displayMapVar[xx][yy];

            if (c == "Z") tempText += wallChar;
            if (c == "8") tempText += oobChar;
            if (c == "O" && !center) tempText += itemChar;
            if (c == "X" && !center) tempText += emptyChar;
            if (c == "W" && !center) tempText += warpChar;
            if (center) tempText += centerChar;
            
            tempText += " ";
            if(center) {
                tempText+= "</span>"
            }
        }
        if (yy < viewDiameter - 1) tempText+= "<br>";
    }
    mapElement.innerHTML = tempText;
    refreshMapStyle();
    refreshScore();
}


isWalkable = (room,x,y) => {
    if(x < 0) return false;
    if(x >= mapVar[room].mapBoundX) return false;
    if(y < 0) return false;
    if(y >= mapVar[room].mapBoundY) return false;
    if(mapVar[room].xy[x][y] == "Z"){
        return false;
    }
    return true;
}


moveLeft = () => {
    if(isWalkable(currentPosition.room,currentPosition.x-1,currentPosition.y)) {
        currentPosition.x--;
        numSteps++;
        displayMap();
    }
}

moveRight = () => {
    if(isWalkable(currentPosition.room,currentPosition.x+1,currentPosition.y)) {
        currentPosition.x++;
        numSteps++;
        displayMap();
    }
}

moveUp = () => {
    if(isWalkable(currentPosition.room,currentPosition.x,currentPosition.y-1)) {
        currentPosition.y--;
        numSteps++;
        displayMap();
    }
}

moveDown = () => {
    if(isWalkable(currentPosition.room,currentPosition.x,currentPosition.y+1)) {
        currentPosition.y++;
        numSteps++;
        displayMap();
    }
}

mapElement.addEventListener("pointerdown",(event) => {
    let rect = mapElement.getBoundingClientRect();
    let midx = (rect.left + rect.right)/2.0;
    let midy = (rect.top + rect.bottom)/2.0;
    if(event.x > midx + 20 && event.y < midy + 50 && event.y > midy - 50) moveRight();
    if(event.x < midx - 20 && event.y < midy + 50 && event.y > midy - 50) moveLeft();
    if(event.y > midy + 20 && event.x < midx + 50 && event.x > midx - 50) moveDown();
    if(event.y < midy - 20 && event.x < midx + 50 && event.x > midx - 50) moveUp();
})


leftElement.onclick = () => {
    moveLeft();
}
rightElement.onclick = () => {
    moveRight();
}
upElement.onclick = () => {
    moveUp();
}
downElement.onclick = () => {
    moveDown();
}

questionRefresh = () => {
    if(instructionOrder[0].questionType == "moveTo"){
        checkPlaces[instructionOrder[0].targetPlaceIndex].pickedUp = true;
        let room = checkPlaces[instructionOrder[0].targetPlaceIndex].room;
        let x = checkPlaces[instructionOrder[0].targetPlaceIndex].x;
        let y = checkPlaces[instructionOrder[0].targetPlaceIndex].y;
        mapVar[room].xy[x][y] = "X";
        refreshCheckPlaces(mapVar[room]);
        refreshWordsInside();
    }

    questionElement.innerHTML = "";
    for(let i = 0; i < instructionOrder.length; i++){
        if(instructionOrder[i].questionType == "moveTo"){
            questionElement.innerHTML += "move " + checkPlaces[instructionOrder[i].targetPlaceIndex].word;
            questionElement.innerHTML += " to room:" + instructionOrder[i].room + ", x:" + instructionOrder[i].x + ", y:" + instructionOrder[i].y;
        }
        if (instructionOrder[i].questionType == "goTo"){
            questionElement.innerHTML += "go to " + checkPlaces[instructionOrder[i].targetPlaceIndex].word;
        }
        if (instructionOrder[i].questionType == "math"){
            questionElement.innerHTML += "calc " + instructionOrder[i].question;
        }
        if (instructionOrder[i].questionType == "click"){
            questionElement.innerHTML += instructionOrder[i].question;
        }
        if (i < instructionOrder.length -1) questionElement.innerHTML += "<br>";
    }
}

moveToQuestion = () => {
    let moveToPlace = findSuitableMovePlace();
    let targetPlaceIndex = instructionOrder[instructionOrder.length-1].targetPlaceIndex;
    instructionOrder.push({questionType: "moveTo",moveToX: moveToPlace.x,x:moveToPlace.x,y:moveToPlace.y,moveToY: moveToPlace.y,room:moveToPlace.room, moveToRoom: moveToPlace.room,targetPlaceIndex: targetPlaceIndex});
}

packGoToQuestion = (placeIndex) => {
    return {targetPlaceIndex: placeIndex, x: checkPlaces[placeIndex].x, y: checkPlaces[placeIndex].y, room: checkPlaces[placeIndex].room, questionType:"goTo",place:checkPlaces[placeIndex]};
}

packMathQuestion = () => {
    let answer = 0;
    let question = "";
    for(let i = 0; i < mathQuestionsDepth; i++){
        if (i == 0) {
            answer = basicRandom(-9,9);
            question += answer.toString();
        }
        else {
            let num = basicRandom(-9,9);
            answer += num;
            question += " + " + num.toString();
        }
    }
    return {answer: answer, question: question, questionType: "math"};
}

mathQuestion = () => {
    instructionOrder.push(packMathQuestion());
}

refreshClickQuestion = (instruction) => {
    instruction.elements.correct.style.left = basicRandom(400,1000);
    instruction.elements.correct.style.top = basicRandom(50,800);
    instruction.elements.correct.style.border = "2px solid black";
    instruction.elements.correct.innerHTML = instruction.answer;
    instruction.elements.correct.style.width = basicRandom(80,100);
    instruction.elements.correct.style.height = basicRandom(20,50);
    instruction.elements.correct.style.position = "absolute";
    instruction.elements.correct.style.fontFamily = "Verdana";


    instruction.elements.incorrect.style.left = basicRandom(400,1000);
    instruction.elements.incorrect.style.top = basicRandom(50,800);
    instruction.elements.incorrect.style.border = "2px solid black";
    let correctAnswer = instruction.answer;
    let incorrectAnswer = "";
    
    // decoy for SVG type
    if(instruction.place.wordType == "svg") {
        let alterSvgConfig = dCopy(instruction.place.svgConfig);

        while(SVGHTMLGroup(alterSvgConfig) == SVGHTMLGroup(instruction.place.svgConfig)){
            let r = basicRandom(1,6);
            if(r == 1) alterSvgConfig.circle1.fillColorObject = randColorObject();
            if(r == 2) alterSvgConfig.circle1.strokeColorObject = randColorObject();
            if(r == 3) alterSvgConfig.circle2.fillColorObject = randColorObject();
            if(r == 4) alterSvgConfig.circle2.strokeColorObject = randColorObject();
            if(r == 5) alterSvgConfig.square.fillColorObject = randColorObject();
            if(r == 6) alterSvgConfig.square.strokeColorObject = randColorObject();
        }
        incorrectAnswer = SVGHTMLGroup(alterSvgConfig);
    }
    // decoy for text type
    else {
        let incorrectCharIndex = basicRandom(0,correctAnswer.length-1);
        incorrectAnswer = correctAnswer.substring(0, incorrectCharIndex) + getRandChar()  + correctAnswer.substring(incorrectCharIndex + 1);
    }
    
    instruction.elements.incorrect.innerHTML = incorrectAnswer;
    instruction.elements.incorrect.style.width = basicRandom(80,100);
    instruction.elements.incorrect.style.height = basicRandom(20,50);
    instruction.elements.incorrect.style.position = "absolute";
    instruction.elements.incorrect.style.fontFamily = "Verdana";

    instruction.elements.finished.style.left = basicRandom(400,1000);
    instruction.elements.finished.style.top = basicRandom(50,800);
    instruction.elements.finished.style.width = basicRandom(10,50);
    instruction.elements.finished.style.height = basicRandom(10,50);
    instruction.elements.finished.style.backgroundColor = "green"
    instruction.elements.finished.style.position = "absolute";
    instruction.elements.finished.innerHTML = instruction.answer;
    instruction.elements.finished.style.fontFamily = "Verdana";
}

finishClickQuestion = (instruction) => {
    instruction.elements.correct.remove();
    instruction.elements.incorrect.remove();
    instruction.elements.finished.remove();

    newQuestion(true, instruction.orderIndex);

    feedbackElement.textContent += "\nyou got it!"
    numCorrect++;
    currentTime = performance.now();
    answerTime = currentTime - lastTime;
    totalTime = currentTime - startTime;
    averageTime = totalTime / numCorrect;
    lastTime = currentTime;
    refreshScore();
}

getInstructionByWord = (word) => {
    for(let i = 0; i < instructionOrder.length; i++){
        if(instructionOrder[i].questionType == "click" && instructionOrder[i].answer == word){
            instructionOrder[i].orderIndex = i;
            return instructionOrder[i];
        }
    }
    return null;
}

passesOrderSettings = (i) => {
    if(i == 0 || answerOutOfOrder) return true;
    feedbackElement.innerHTML += "<br>question attempt is out of order"
    return false;
}

incorrectClick = (word) => {
    instruction = getInstructionByWord(word);
    if(!passesOrderSettings(instruction.orderIndex)) return;
    instruction.reps = instruction.originalReps;
    refreshClickQuestion(instruction);
}
correctClick = (word) => {
    instruction = getInstructionByWord(word);
    if(!passesOrderSettings(instruction.orderIndex)) return;
    instruction.reps--;
    if(instruction.reps < 0) instruction.reps = instruction.originalReps;
    refreshClickQuestion(instruction);
}
finishedClick = (word) => {
    instruction = getInstructionByWord(word);
    if(!passesOrderSettings(instruction.orderIndex)) return;
    if(instruction.reps == 0) finishClickQuestion(instruction);
    else instruction.reps = instruction.originalReps;
    refreshClickQuestion(instruction);
}


packClickQuestionElements = (word) => {
    let elements = {};
    
    elements.correct = document.createElement("div");
    elements.incorrect = document.createElement("div");
    elements.finished = document.createElement("div");

    elements.correct.addEventListener("pointerdown", () => {correctClick(word)});
    elements.incorrect.addEventListener("pointerdown", () => {incorrectClick(word)});
    elements.finished.addEventListener("pointerdown", () => {finishedClick(word)});

    document.body.append(elements.correct);
    document.body.append(elements.incorrect);
    document.body.append(elements.finished);

    return elements;
}

packClickQuestion = () => {
    let place = checkPlaces[basicRandom(0,checkPlaces.length-1)];
    let reps = basicRandom(1,maxClickReps);
    let question = "click " + place.word + " " + reps + " times";
    let elements = packClickQuestionElements(place.word);
    return {questionType: "click", answer: place.word, question: question, elements: elements, reps: reps, originalReps: reps, place:place};
}

clickQuestion = () => {
    let instruction = packClickQuestion();
    refreshClickQuestion(instruction);
    instructionOrder.push(instruction);
}

goToQuestion = () => {
    let targetPlaceIndex = basicRandom(0,checkPlaces.length-1);
    if (instructionOrder.length < 1) {
        instructionOrder.push(packGoToQuestion(targetPlaceIndex)); // nothing to compare to
        return;
    }
    // try to make different target than previous instruction
    for (let i = 0; i < 1000; i++){
        if(targetPlaceIndex != instructionOrder[instructionOrder.length-1].targetPlaceIndex) { // different from last
            instructionOrder.push(packGoToQuestion(targetPlaceIndex));
            return;
        }
        targetPlaceIndex = basicRandom(0,checkPlaces.length-1); // try again
    }
    // push same as previous question, failed to change
    instructionOrder.push(packGoToQuestion(targetPlaceIndex));
}

getNewQuestionKind = () => {
    // pick for chance of moveto question
    let r = Math.random();
    let mathChance = 1.0 / mathQuestionsRate;
    let moveToChance = 1.0 / moveToRate;
    let clickChance = 1.0 / clickQuestionsRate;
    if(!mathQuestions) mathChance = 0;
    if(!clickQuestions) clickChance = 0;
    if(!moveAroundMode) mathToChance = 0;

    // moveto requires previous question be a goTo for pickup
    if(r < moveToChance){
        if(moveAroundMode && instructionOrder.length > 0){
            if(instructionOrder[instructionOrder.length-1].questionType == "goTo")
            {
                moveToQuestion();
                return;
            }
        }
    }

    if(r >= moveToChance && r < moveToChance + mathChance) {
        if(mathQuestions){
            mathQuestion();
            return;
        }
    }

    if(r >= moveToChance + mathChance && r < moveToChance + mathChance + clickChance) {
        if(clickQuestions){
            clickQuestion();
            return;
        }
    }

    goToQuestion();
}

fillQuestions = () => {
    while (instructionOrder.length < numIncomingInstructions) newQuestion(false);
}

newQuestion = (answered = true, instruction_id = 0) => {
    getNewQuestionKind();
    if(answered) {
        questionAnswered(instruction_id);
    }
    questionRefresh();
}
questionAnswered = (instruction_id = 0) => {
    instructionOrder.splice(instruction_id,1);
}

removeItemAll = (arr, value) => {
  var i = 0;
  while (i < arr.length) {
    if (arr[i] === value) {
      arr.splice(i, 1);
    } else {
      ++i;
    }
  }
  return arr;
}


/*
setMapVar = () => {
    for(let i = 0; i < mapBoundX; i++){
        mapVar.push([]);
        for(let j = 0; j < mapBoundY; j++){
            mapVar[i].push("X");
        }
    }
}
*/


goodWall = (room, x,y) => {
    wallcheck = [["","",""],["","",""],["","",""]];
    for(let xcheck = -1; xcheck <=1; xcheck++){
        for(let ycheck = -1; ycheck <=1; ycheck++){
            if(x + xcheck < 0 || x + xcheck >= room.mapBoundX) wallcheck[xcheck+1][ycheck+1] = "Z";
            else if(y + ycheck < 0 || y + ycheck >= room.mapBoundY) wallcheck[xcheck+1][ycheck+1] = "Z";
            else {
                wallcheck[xcheck+1][ycheck+1] = room.xy[x+xcheck][y+ycheck];
            }
        }
    }
    if(wallcheck[1][1] == "Z") return false; 
    if(wallcheck[1][0] == "Z" || wallcheck[0][0] == "Z" || wallcheck[2][0] == "Z") {
        if(wallcheck[0][2] == "Z" || wallcheck[1][2] == "Z" || wallcheck[2][2] == "Z" ){
            return false;
        }
    }
    if(wallcheck[0][1] == "Z" || wallcheck[0][0] == "Z" || wallcheck[0][2] == "Z") {
        if(wallcheck[2][0] == "Z" || wallcheck[2][1] == "Z" || wallcheck[2][2] == "Z" ){
            return false;
        }
    }
    if(wallcheck[1][2] == "Z" || wallcheck[0][2] == "Z" || wallcheck[2][2] == "Z") {
        if(wallcheck[0][0] == "Z" || wallcheck[1][0] == "Z" || wallcheck[2][0] == "Z" ){
            return false;
        }
    }
    if(wallcheck[2][1] == "Z" || wallcheck[2][0] == "Z" || wallcheck[2][2] == "Z") {
        if(wallcheck[0][0] == "Z" || wallcheck[0][1] == "Z" || wallcheck[0][2] == "Z" ){
            return false;
        }
    }
    return true;
}

goodWallPure = (room,x,y) => {
    if(x < 0 || x >= room.mapBoundX || y < 0 || y >= room.mapBoundY) return false;
    wallcheck = [["","",""],["","",""],["","",""]];
    for(let xcheck = -1; xcheck <=1; xcheck++){
        for(let ycheck = -1; ycheck <=1; ycheck++){
            // is pt within bounds
            if(x + xcheck >= 0 && x + xcheck < room.mapBoundX) {
                if(y + ycheck >= 0 && y + ycheck < room.mapBoundY) {
                    //let s = " " + (x) + " " + (y);
                    //console.log(s)
                    //s = " " + (x+xcheck) + " " + (y+ycheck);
                    //console.log(s)
                    if(room.xy[x+xcheck][y+ycheck] == "Z") return false; 
                }
            }
        }
    }
    return true;
}

addRoom = () => {
    let mapx = basicRandom(minMapX,maxMapX);
    let mapy = basicRandom(minMapY,maxMapY);
    mapVar.push({xy:[],walls:[],places:[],warps:[],mapBoundX:mapx,mapBoundY:mapy});
    let roomNum = mapVar.length-1;
    for(let x = 0; x < mapx; x++){
        mapVar[roomNum].xy.push([]);
        for(let y = 0; y < mapy; y++){
            mapVar[roomNum].xy[x].push("X");
        }
    }
    if(allowWalls) wallAlgorithm(mapVar[roomNum]);
    let warpRoomNum = -1;
    if(bidirectionalWarps){
        warpRoomNum = basicRandom(0,roomNum-1);
        addWarp(roomNum,warpRoomNum,true);
    }
    else{
        addWarp(roomNum,basicRandom(0,roomNum-1),false);
        warpRoomNum = basicRandom(0,roomNum-1);
        addWarp(warpRoomNum,roomNum,false);
    }
    numRooms++;
    if(allowHints){
        feedbackElement.textContent += "new room added:\n";
        feedbackElement.textContent += "warp from room " + warpRoomNum;
    }
}

initializeRooms = (_numRooms,_minMapX,_maxMapX,_minMapY,_maxMapY) => {
    for(let i = 0; i < _numRooms; i++){
        let mapx = basicRandom(_minMapX,_maxMapX);
        let mapy = basicRandom(_minMapY,_maxMapY);
        mapVar.push({xy:[],walls:[],places:[],warps:[],mapBoundX:mapx,mapBoundY:mapy});
        for(let x = 0; x < mapx; x++){
            mapVar[i].xy.push([]);
            for(let y = 0; y < mapy; y++){
                mapVar[i].xy[x].push("X");
            }
        }
        
    }
}

addWarp = (roomStart, roomEnd, twoway = true) => {
    
    for(let i = 0; i <= 1000; i++){
        let randxStart = basicRandom(0,mapVar[roomStart].mapBoundX-1);
        let randyStart = basicRandom(0,mapVar[roomStart].mapBoundY-1);
        if(mapVar[roomStart].xy[randxStart][randyStart] != "Z" || !preventWallOverwrite) {
            if(mapVar[roomStart].xy[randxStart][randyStart] != "W" && mapVar[roomStart].xy[randxStart][randyStart] != "O") {
                for(let j = 0; j <= 1000; j++){
                    let randxEnd = basicRandom(0,mapVar[roomEnd].mapBoundX-1);
                    let randyEnd = basicRandom(0,mapVar[roomEnd].mapBoundY-1);
                    if(mapVar[roomEnd].xy[randxEnd][randyEnd] != "Z" || !preventWallOverwrite) {
                        if(mapVar[roomEnd].xy[randxEnd][randyEnd] != "W" && mapVar[roomEnd].xy[randxEnd][randyEnd] != "O") {
                            mapVar[roomStart].xy[randxStart][randyStart] = "W";
                            mapVar[roomStart].warps.push({x:randxStart,y:randyStart,toRoom:roomEnd,
                                toX: randxEnd, toY: randyEnd});
                                if(twoway){
                                    mapVar[roomEnd].xy[randxEnd][randyEnd] = "W";
                                    mapVar[roomEnd].warps.push({x:randxEnd,y:randyEnd,toRoom:roomStart,
                                        toX: randxStart, toY: randyStart});
                                }
                            return true;
                        }
                    }
                }
            }
        }
    }
    return false;
}

initializeWarps = () => {
    for(let i = 1; i < numRooms; i++){
        if(bidirectionalWarps){
            addWarp(i,basicRandom(0,i-1),true);
        }
        else{
            addWarp(i,basicRandom(0,i-1),false);
            addWarp(basicRandom(0,i-1),i,false);
        }
    }
    for(let i = 1; i <= numExtraConnections; i++){
        addWarp(basicRandom(0,numRooms-1),basicRandom(0,numRooms-1),bidirectionalWarps);
    }
}


makeWallAny = (room) => {
    let x = basicRandom(0,room.mapBoundX-1);
    let y = basicRandom(0,room.mapBoundY-1);
    if(goodWallPure(room,x,y)) {
        room.xy[x][y] = "Z";
        room.walls.push({x:x,y:y});
    }
}

makeWallNearby = (room) => {
    let r = basicRandom(0,room.walls.length-1);
    let x = room.walls[r].x;
    let y = room.walls[r].y;

    if(allowDiagonals){
        x = room.walls[r].x + basicRandom(-1,1);
        y = room.walls[r].y + basicRandom(-1,1);
    }
    else{ 
        // vertical or horizontal only
        if(basicRandom(0,1)==0){
            x+=basicRandom(-1,1);
        }
        else {
            y+=basicRandom(-1,1);
        }
    }
    
    if(goodWall(room,x,y)) {
        room.xy[x][y] = "Z";
        room.walls.push({x:x,y:y});
    }
}


wallAlgorithm = (room) => {
    
    makeWallAny(room);
    for ( let i = 0; i < room.mapBoundX * room.mapBoundY * 10; i ++){
        let r = basicRandom(0,10);
        if(r==0){
            makeWallAny(room);
        }
        else {
            makeWallNearby(room);
        }
    }
    
}

doCommands = (wordListArray) => {
    wordListArray = removeItemAll(wordListArray,"");
    for(let i = 0; i < wordListArray.length; i++){
        if(wordListArray[i].substr(0,5).toLowerCase() == "mapx "){
            mapBoundX = parseInt(wordListArray[i].substring(5));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,5).toLowerCase() == "mapy "){
            mapBoundY = parseInt(wordListArray[i].substring(5));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,10).toLowerCase() == "randchars "){
            randchars = true;
            numRandChars = parseInt(wordListArray[i].substring(10));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,9).toLowerCase() == "randnums "){
            randchars = true;
            numRandChars = parseInt(wordListArray[i].substring(9));
            randCharList = randNumList;
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,7).toLowerCase() == "nowalls"){
            allowWalls = false;
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,10).toLowerCase() == "viewrange "){
            viewRange = parseInt(wordListArray[i].substring(10));
            viewDiameter = 1 + (viewRange * 2);
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,8).toLowerCase() == "addrate "){
            addRate = parseInt(wordListArray[i].substring(8));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,18).toLowerCase() == "numstartingplaces "){
            numStartingPlaces = parseInt(wordListArray[i].substring(18));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,8).toLowerCase() == "maxmapx "){
            maxMapX = parseInt(wordListArray[i].substring(8));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,8).toLowerCase() == "maxmapy "){
            maxMapY = parseInt(wordListArray[i].substring(8));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,8).toLowerCase() == "minmapx "){
            minMapX = parseInt(wordListArray[i].substring(8));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,8).toLowerCase() == "minmapy "){
            minMapY = parseInt(wordListArray[i].substring(8));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,10).toLowerCase() == "allowhints"){
            allowHints = true;
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,9).toLowerCase() == "numrooms "){
            numRooms = parseInt(wordListArray[i].substring(9));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,17).toLowerCase() == "extraconnections "){
            numExtraConnections = parseInt(wordListArray[i].substring(17));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,19).toLowerCase() == "unidirectionalwarps"){
            bidirectionalWarps = false;
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,14).toLowerCase() == "movearoundmode"){
            moveAroundMode = true;
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,10).toLowerCase() == "movetorate"){
            moveToRate = parseInt(wordListArray[i].substring(10));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,11).toLowerCase() == "newroommode"){
            newRoomMode = true;
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,11).toLowerCase() == "newroomrate"){
            newRoomRate = parseInt(wordListArray[i].substring(11));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,23).toLowerCase() == "numincominginstructions"){
            numIncomingInstructions = parseInt(wordListArray[i].substring(23));
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,16).toLowerCase() == "answeroutoforder"){
            answerorderoforder = true;
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,6).toLowerCase() == "typing"){
            noTyping = false;
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,6).toLowerCase() == "nomath"){
            mathQuestions = false;
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,7).toLowerCase() == "noclick"){
            clickQuestions = false;
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,7).toLowerCase() == "notimer"){
            timerQuestions = false;
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,3).toLowerCase() == "svg"){
            SVGQuestions = true;
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,7).toLowerCase() == "svgrate"){
            SVGQuestionsRate = parseInt(wordListArray[i].substring(7));;
            wordListArray.splice(i,1);
            i--;
        }
        else if(wordListArray[i].substr(0,23).toLowerCase() == "maxclick"){
            maxClickReps = parseInt(wordListArray[i].substring(8));
            wordListArray.splice(i,1);
            i--;
        }
    }
}

initElement.onclick = () => {
    sessionStarted = true;
    startTime = performance.now();
    lastTime = startTime;
    answerElement.placeholder = "type here and hit check!"
    hideShowNonInitButtons("inline-block");
    refreshMapStyle();
    
    initElement.style.display = "none"

    wordListString = answerElement.value
    wordListString = wordListString.replace("\r\g","");
    let wordListArray = wordListString.split("\n");
    doCommands(wordListArray);
    wordDict = wordListArray;


    if (noTyping == true) {
        answerElement.style.display = "none";
        mathQuestions = false;
    }
    else answerElement.style.display = "";
    
    answerElement.value = "";
    answerElement.cols = 50
    answerElement.rows = 1

    mapElement.style.display = ""

    
    checkPlaces = [];
    lastCheckPlace = {};

    mapVar = []
    displayMapVar = []

    initializeRooms(numRooms,minMapX,maxMapX,minMapY,maxMapY);

    
    if(allowWalls){
        mapVar.forEach(room => wallAlgorithm(room));
    }

    initializeWarps();

    for(let i = 0; i < viewDiameter; i++){
        displayMapVar.push([]);
        for(let j = 0; j < viewDiameter; j++){ 
            displayMapVar[i].push("");
        }
    }


    currentPosition = {x: 0, y: 0, room:0};
    for(let i = 1; i <= numStartingPlaces; i++) addCheckPlace();
    fillQuestions();
    displayMap();
    
}

goInside = (room, x, y) => {
    let wentInside = false;
    mapVar[room].warps.forEach(w => {if(w.x == x && w.y == y){
        currentPosition.room = w.toRoom;
        currentPosition.x = w.toX;
        currentPosition.y = w.toY;
        wentInside = true;
    }});
    displayMap();
    return wentInside;
}

let moveKeys = (event) => {
    if((event.key == "ArrowUp" || event.key =="w") && sessionStarted) moveUp(); 
    if((event.key == "ArrowDown" || event.key =="s") && sessionStarted) moveDown(); 
    if((event.key == "ArrowLeft" || event.key =="a") && sessionStarted) moveLeft(); 
    if((event.key == "ArrowRight" || event.key =="d") && sessionStarted) moveRight(); 
    if (noTyping == false) answerElement.value = "";
}

document.body.addEventListener("keydown", (event)=>{
    if(!sessionStarted) return;
    if(document.activeElement == answerElement){
        if((positionMatching() && !noTyping)) return;
    }
    if(event.key == "Enter" && sessionStarted) {
        let room = currentPosition.room;
        let x = currentPosition.x;
        let y = currentPosition.y;
        if(mapVar[room].xy[x][y] == "W"){
            goInside(room, x, y);
        }
        else checkAnswers(); 
    }
    moveKeys(event);
});

positionMatchingInstruction = (i) => {
    if(instructionOrder[i].questionType == "math") return true;
    if(instructionOrder[i].questionType == "moveTo"){
        if((currentPosition.x == instructionOrder[i].moveToX) && (currentPosition.y == instructionOrder[i].moveToY) && (currentPosition.room == instructionOrder[i].moveToRoom)) return true;
    }
    if(instructionOrder[i].questionType == "goTo"){
        if((currentPosition.x == checkPlaces[instructionOrder[i].targetPlaceIndex].x) && (currentPosition.y == checkPlaces[instructionOrder[i].targetPlaceIndex].y) && (currentPosition.room == checkPlaces[instructionOrder[i].targetPlaceIndex].room)) return true;
    }
    return false;
}

positionMatching = () => {
    // in order only
    if(positionMatchingInstruction(0)) return true;
    if(answerOutOfOrder == false) return false; 
    
    // including out of order possibility
    for(let i = 1; i < instructionOrder.length; i++){
        if(positionMatchingInstruction(i)) return true;
    }
    return false;
}

answerElement.addEventListener("keydown", (event)=>{
    if(!sessionStarted) return;
    if((event.key == "Enter") && sessionStarted && positionMatching() ) {
        checkAnswers();
        event.preventDefault();
        answerElement.value = "";
    }
    else {
        if(positionMatching() == false) {
            event.preventDefault();
            answerElement.value = "";
        }
    }
});


</script>
</body>
</html>